import {
    AclRequest,
    Config,
    Export,
    File,
    Html,
    Include,
    Map,
    MinMtaVersion,
    MTASAMeta,
    Script,
    Setting,
    XMLTagData,
} from './types';
import { Element, js2xml } from 'xml-js';
import { ResourceData, simpleTsDiagnostic } from '../utils';
import fs from 'fs';
import path from 'path';
import { Diagnostic, DiagnosticCategory } from 'typescript';

export const LUA_LIB_FILENAME = 'lualib_bundle.lua';

function genComment(message: string) {
    return {
        type: 'comment',
        comment: message,
    };
}

function objectValuesToString(
    object: Readonly<Record<string, { toString: () => string }>>,
): Record<string, string> {
    const newObject: Record<string, string> = {};
    for (const entry of Object.entries(object)) {
        newObject[entry[0]] = entry[1].toString();
    }
    return newObject;
}

function genScriptTag(
    script: Readonly<Script>,
    hideAdditionalProps: boolean,
): Element {
    const processedScript: Script = {
        ...script,
        src: script.src.replace(/\.ts$/, '.lua'),
    };
    if (hideAdditionalProps) {
        delete processedScript.bundled;
    }

    return {
        type: 'element',
        name: 'script',
        attributes: objectValuesToString(processedScript as Readonly<Script>),
    };
}

function genMapTag(map: Readonly<Map>): Element {
    return {
        type: 'element',
        name: 'map',
        attributes: objectValuesToString(map),
    };
}

function genFileTag(
    file: Readonly<File>,
    hideAdditionalProps: boolean,
): Element {
    const processedFile: File = {
        ...file,
    };
    if (hideAdditionalProps) {
        delete processedFile.doCompileCheck;
    }

    return {
        type: 'element',
        name: 'file',
        attributes: objectValuesToString(file),
    };
}

function genIncludeTag(include: Readonly<Include>): Element {
    return {
        type: 'element',
        name: 'include',
        attributes: objectValuesToString(include),
    };
}

function genConfigTag(config: Readonly<Config>): Element {
    return {
        type: 'element',
        name: 'config',
        attributes: objectValuesToString(config),
    };
}

function genExportTag(exportData: Readonly<Export>): Element {
    return {
        type: 'element',
        name: 'export',
        attributes: objectValuesToString(exportData),
    };
}

function genHtmlTag(html: Readonly<Html>): Element {
    return {
        type: 'element',
        name: 'html',
        attributes: objectValuesToString(html),
    };
}

function genSettingTag(setting: Readonly<Setting>): Element {
    return {
        type: 'element',
        name: 'setting',
        attributes: objectValuesToString(setting),
    };
}

function getMinMtaVersionTag(data: Readonly<MinMtaVersion>): Element {
    return {
        type: 'element',
        name: 'setting',
        attributes: objectValuesToString(data),
    };
}

function genAclRequestTag(data: Readonly<AclRequest>): Element {
    return {
        type: 'element',
        name: 'setting',
        attributes: objectValuesToString(data),
    };
}

function genCustomTag(tagData: Readonly<XMLTagData>): Element {
    let innerTags: Element[] = [];
    if (typeof tagData.value === 'string') {
        innerTags = [
            {
                type: 'text',
                text: tagData.value,
            },
        ];
    } else if (tagData.value !== undefined) {
        innerTags = tagData.value.map(inner => genCustomTag(inner));
    }

    return {
        type: 'element',
        name: tagData.name,
        attributes: tagData.properties,
        elements: innerTags,
    };
}

export function generateResourceMetaObject(
    meta: MTASAMeta,
    data: ResourceData,
): Element {
    const emptyComment = {
        type: 'comment',
        comment: '',
    };

    const luaLibExists = fs.existsSync(
        path.join(data.outDir, LUA_LIB_FILENAME),
    );
    const hideAdditionalProps = !(
        meta.compilerConfig.outMetaAdditionalProperties ?? true
    );
    const commentWrapper = (...args: Element[]): Element[] => {
        if (
            meta.compilerConfig.outMetaComments ||
            meta.compilerConfig.outMetaComments == undefined
        ) {
            return args;
        }

        return [];
    };

    return {
        elements: [
            {
                type: 'element',
                name: 'meta',
                elements: [
                    ...commentWrapper(
                        genComment(
                            'This file has been generated by' +
                                ' https://mtasa-typescript.github.io/',
                        ),
                        genComment(
                            'DO NOT EDIT THIS FILE MANUALLY. ' +
                                'ALL CHANGES WILL BE LOST',
                        ),
                        emptyComment,
                        genComment('Resource information'),
                    ),
                    {
                        type: 'element',
                        name: 'info',
                        attributes: {
                            ...meta.info,
                            gamemodes: meta.info.gamemodes?.join(','),
                        },
                    },
                    ...commentWrapper(
                        emptyComment,
                        genComment('Library scripts'),
                    ),
                    luaLibExists
                        ? genScriptTag(
                              {
                                  type: 'shared',
                                  src: LUA_LIB_FILENAME,
                                  cache: false,
                              },
                              hideAdditionalProps,
                          )
                        : {},
                    ...commentWrapper(emptyComment, genComment('Scripts')),
                    ...(meta.scripts?.map(data =>
                        genScriptTag(data, hideAdditionalProps),
                    ) ?? []),
                    ...commentWrapper(emptyComment, genComment('Maps')),
                    ...(meta.maps?.map(data => genMapTag(data)) ?? []),
                    ...commentWrapper(emptyComment, genComment('Files')),
                    ...(meta.files?.map(data =>
                        genFileTag(data, hideAdditionalProps),
                    ) ?? []),
                    ...commentWrapper(emptyComment, genComment('Includes')),
                    ...(meta.includes?.map(data => genIncludeTag(data)) ?? []),
                    ...commentWrapper(emptyComment, genComment('Configs')),
                    ...(meta.configs?.map(data => genConfigTag(data)) ?? []),
                    ...commentWrapper(emptyComment, genComment('Exports')),
                    ...(meta.exports?.map(data => genExportTag(data)) ?? []),
                    ...commentWrapper(emptyComment, genComment('HTMLs')),
                    ...(meta.htmls?.map(data => genHtmlTag(data)) ?? []),
                    ...commentWrapper(emptyComment, genComment('Settings')),
                    {
                        type: 'element',
                        name: 'settings',
                        elements:
                            meta.settings?.map(data => genSettingTag(data)) ??
                            [],
                    },
                    ...commentWrapper(
                        emptyComment,
                        genComment('Minimum version required'),
                    ),
                    meta.minMtaVersion
                        ? getMinMtaVersionTag(meta.minMtaVersion)
                        : {},
                    ...commentWrapper(emptyComment, genComment('ACL Requests')),
                    {
                        type: 'element',
                        name: 'aclrequest',
                        elements:
                            meta.aclRequests?.map(data =>
                                genAclRequestTag(data),
                            ) ?? [],
                    },
                    ...commentWrapper(
                        emptyComment,
                        genComment('Sync map element data (or not)'),
                    ),
                    meta.syncMapElementData
                        ? {
                              type: 'element',
                              name: 'sync_map_element_data',
                              elements: [
                                  {
                                      type: 'text',
                                      text: meta.syncMapElementData,
                                  },
                              ],
                          }
                        : {},
                    ...commentWrapper(emptyComment, genComment('OOP')),
                    {
                        type: 'element',
                        name: 'oop',
                        elements: [
                            {
                                type: 'text',
                                text: 'true',
                            },
                        ],
                    },
                    ...commentWrapper(
                        emptyComment,
                        genComment('Download Priority'),
                    ),
                    meta.downloadPriorityGroup
                        ? {
                              type: 'element',
                              name: 'download_priority_group',
                              elements: [
                                  {
                                      type: 'text',
                                      text: 'true',
                                  },
                              ],
                          }
                        : {},
                    ...commentWrapper(emptyComment, genComment('Custom Tags')),
                    ...(meta.additionalTags?.map(data => genCustomTag(data)) ??
                        []),
                ],
            },
        ],
    };
}

export function generateResourceMetaContent(
    meta: MTASAMeta,
    data: ResourceData,
): {
    content: string;
    diagnostics: Diagnostic[];
} {
    const jsMeta = generateResourceMetaObject(meta, data);
    if (jsMeta.elements === undefined || jsMeta.elements.length === 0) {
        return {
            content: '<meta><info name="Generation error happened" /></meta>',
            diagnostics: [
                simpleTsDiagnostic(
                    'Internal error: meta.xml contains no objects',
                    DiagnosticCategory.Error,
                ),
            ],
        };
    }

    jsMeta.elements[0].elements = jsMeta.elements?.[0].elements?.filter(
        element => Object.keys(element).length > 0,
    );

    return {
        content: js2xml(jsMeta, {
            compact: false,
            spaces: 4,
        }),
        diagnostics: [],
    };
}
