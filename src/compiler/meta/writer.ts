import {
    AclRequest,
    Config,
    Export,
    File,
    Html,
    Include,
    Map,
    MinMtaVersion,
    MTASAMeta,
    Script,
    Setting,
    XMLTagData,
} from './types';
import { Element, js2xml } from 'xml-js';

function genComment(message: string) {
    return {
        type: 'comment',
        comment: message,
    };
}

function objectValuesToString(
    object: Readonly<Record<string, any>>,
): Record<string, string> {
    const newObject: Record<string, string> = {};
    for (const entry of Object.entries(object)) {
        newObject[entry[0]] = entry[1].toString();
    }
    return newObject;
}

function genScriptTag(script: Readonly<Script>): Element {
    const processedScript: Script = {
        ...script,
        src: script.src.replace(/\.ts$/, '.lua'),
    };

    return {
        type: 'element',
        name: 'script',
        attributes: objectValuesToString(processedScript),
    };
}

function genMapTag(map: Readonly<Map>): Element {
    return {
        type: 'element',
        name: 'map',
        attributes: objectValuesToString(map),
    };
}

function genFileTag(file: Readonly<File>): Element {
    return {
        type: 'element',
        name: 'file',
        attributes: objectValuesToString(file),
    };
}

function genIncludeTag(include: Readonly<Include>): Element {
    return {
        type: 'element',
        name: 'include',
        attributes: objectValuesToString(include),
    };
}

function genConfigTag(config: Readonly<Config>): Element {
    return {
        type: 'element',
        name: 'config',
        attributes: objectValuesToString(config),
    };
}

function genExportTag(exportData: Readonly<Export>): Element {
    return {
        type: 'element',
        name: 'export',
        attributes: objectValuesToString(exportData),
    };
}

function genHtmlTag(html: Readonly<Html>): Element {
    return {
        type: 'element',
        name: 'html',
        attributes: objectValuesToString(html),
    };
}

function genSettingTag(setting: Readonly<Setting>): Element {
    return {
        type: 'element',
        name: 'setting',
        attributes: objectValuesToString(setting),
    };
}

function getMinMtaVersionTag(data: Readonly<MinMtaVersion>): Element {
    return {
        type: 'element',
        name: 'setting',
        attributes: objectValuesToString(data),
    };
}

function genAclRequestTag(data: Readonly<AclRequest>): Element {
    return {
        type: 'element',
        name: 'setting',
        attributes: objectValuesToString(data),
    };
}

function genCustomTag(tagData: Readonly<XMLTagData>): Element {
    let innerTags: Element[] = [];
    if (typeof tagData.value === 'string') {
        innerTags = [
            {
                type: 'text',
                text: tagData.value,
            },
        ];
    } else if (tagData.value !== undefined) {
        innerTags = tagData.value.map(inner => genCustomTag(inner));
    }

    return {
        type: 'element',
        name: tagData.name,
        attributes: tagData.properties,
        elements: innerTags,
    };
}

export function generateResourceMetaObject(meta: MTASAMeta): Element {
    const emptyComment = {
        type: 'comment',
        comment: '',
    };

    return {
        elements: [
            {
                type: 'element',
                name: 'meta',
                elements: [
                    genComment(
                        'This file has been generated by' +
                            ' https://mtasa-typescript.github.io/',
                    ),
                    genComment(
                        'DO NOT EDIT THIS FILE MANUALLY. ' +
                            'ALL CHANGES WILL BE LOST',
                    ),
                    emptyComment,
                    genComment('Resource information'),
                    {
                        type: 'element',
                        name: 'info',
                        attributes: {
                            ...meta.info,
                            gamemodes: meta.info.gamemodes?.join(','),
                        },
                    },
                    emptyComment,
                    genComment('Library scripts'),
                    genScriptTag({
                        type: 'shared',
                        src: 'lualib_bundle.lua',
                        cache: false,
                    }),
                    emptyComment,
                    genComment('Scripts'),
                    ...(meta.scripts?.map(data => genScriptTag(data)) ?? []),
                    emptyComment,
                    genComment('Maps'),
                    ...(meta.maps?.map(data => genMapTag(data)) ?? []),
                    emptyComment,
                    genComment('Files'),
                    ...(meta.files?.map(data => genFileTag(data)) ?? []),
                    emptyComment,
                    genComment('Includes'),
                    ...(meta.includes?.map(data => genIncludeTag(data)) ?? []),
                    emptyComment,
                    genComment('Configs'),
                    ...(meta.configs?.map(data => genConfigTag(data)) ?? []),
                    emptyComment,
                    genComment('Exports'),
                    ...(meta.exports?.map(data => genExportTag(data)) ?? []),
                    emptyComment,
                    genComment('HTMLs'),
                    ...(meta.htmls?.map(data => genHtmlTag(data)) ?? []),
                    emptyComment,
                    genComment('Settings'),
                    {
                        type: 'element',
                        name: 'settings',
                        elements:
                            meta.settings?.map(data => genSettingTag(data)) ??
                            [],
                    },
                    emptyComment,
                    genComment('Minimum version required'),
                    meta.minMtaVersion
                        ? getMinMtaVersionTag(meta.minMtaVersion)
                        : {},
                    emptyComment,
                    genComment('ACL Requests'),
                    {
                        type: 'element',
                        name: 'aclrequest',
                        elements:
                            meta.aclRequests?.map(data =>
                                genAclRequestTag(data),
                            ) ?? [],
                    },
                    emptyComment,
                    genComment('Sync map element data (or not)'),
                    meta.syncMapElementData
                        ? {
                              type: 'element',
                              name: 'sync_map_element_data',
                              elements: [
                                  {
                                      type: 'text',
                                      text: meta.syncMapElementData,
                                  },
                              ],
                          }
                        : {},
                    emptyComment,
                    genComment('OOP'),
                    {
                        type: 'element',
                        name: 'oop',
                        elements: [
                            {
                                type: 'text',
                                text: 'true',
                            },
                        ],
                    },
                    emptyComment,
                    genComment('Download Priority'),
                    meta.downloadPriorityGroup
                        ? {
                              type: 'element',
                              name: 'download_priority_group',
                              elements: [
                                  {
                                      type: 'text',
                                      text: 'true',
                                  },
                              ],
                          }
                        : {},
                    emptyComment,
                    genComment('Custom Tags'),
                    ...(meta.additionalTags?.map(data => genCustomTag(data)) ??
                        []),
                ],
            },
        ],
    };
}

export function generateResourceMetaContent(meta: MTASAMeta): string {
    const jsMeta = generateResourceMetaObject(meta);
    jsMeta.elements![0].elements = jsMeta.elements?.[0].elements?.filter(
        element => Object.keys(element).length > 0,
    );

    return js2xml(jsMeta, {
        compact: false,
        spaces: 4,
    });
}
